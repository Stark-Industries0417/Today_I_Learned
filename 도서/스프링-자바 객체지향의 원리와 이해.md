## 목차

[2장 자바와 절차적/구조적 프로그래밍](#2-자바와-절차적구조적-프로그래밍)

- [다시보는 main() 메서드: 메서드 스택 프레임](#다시보는-main-메서드-메서드-스택-프레임)

- [블록 구문과 메모리: 블록 스택 프레임](#블록-구문과-메모리-블록-스택-프레임)

[3장 자바와 객체 지향](#3장-자바와-객체-지향)

# 2. 자바와 절차적/구조적 프로그래밍

## 자바 프로그램의 개발과 구동

| 현실 세계                | 가상 세계(자바 월드)                            |
| ------------------------ | ----------------------------------------------- |
| 소프트웨어 개발 도구     | JDK- 자바 개발 도구: JVM용 소프트웨어 개발 도구 |
| 운영체제                 | JRE - 자바 실행 환경: JVM용 OS                  |
| 하드웨어 - 물리적 컴퓨터 | JVM - 자바 가상 기계: 가상의 컴퓨터             |

**자바 개발 도구인 JDK를 이용해, 개발된 프로그램은 JRE에 의해 가상의 컴퓨터인 JVM 상에서 구동된다.**

<hr>

#### 다시보는 main() 메서드: 메서드 스택 프레임

```java
public class Start {
    public static void main(String[] args) {
        System.out.println("Hello OOP!!!");
    }
}

1. JRE는 프로그램 안에 main() 메서드가 있는 확인
2. JRE는 JVM에게 목적 파일을 전해줌 JVM은 그 파일을 실행시킴
3. JVM은 가장 먼저 java.lang 패키지를 T 메모리의 스태틱 영역에 가져다 놓는다.
4. 개발자가 작성한 모든 클래스와 임포트 패키지 역시 스태틱 영역에 가져다 놓음
5. 스택 프레임을 스택 영역에 할당
6. 메서드의 인자 args를 저장할 변수 공간을 스택 프레임의 맨 밑에 확보
7. System.out.println 실행
8. 스택 프레임 소멸
9. JRE는 JVM 종료하고 JRE 자체도 운영체제 상의 메모리에서 사라진다.

스택 프레임은 메서드의 여는 중괄호를 만났을 때 마다 생긴다.
닫는 중괄호를 만나게되면 스택 프레임이 소멸
```

#### 블록 구문과 메모리: 블록 스택 프레임

```java
public class start3 {
    public static void main(String[] args) {
        int i = 10;
        int k = 20;

        if(i == 10) {
            int m = k + 5;
            k = m;
        } else {
            int p = k + 10;
            k = p;
        }
        // k = m + p;
    }
}

1. 여는 중괄호를 만나, if문의 참인 블록의 스택프레임 생성
2. if 스택 프레임 밖에 있으면서 main() 메서드 스택 프레임 안에 있는 k 변수를 연산에 참여시킴 m = k + 5; 실행
3. k = m 으로 k 25를 가지게 됨
4. 닫는 중괄호를 만나 if 블록 스택 프레임은 스택 영역에서 사라짐
5. k = m + p를 실행시키게 되면 m과 p 는 if 블록 스택 프레임이 사라진 뒤 이므로 변수를 찾을 수 없어 에러를 일으키게 된다.

외부 스택 프레임에서 내부 스택 프레임의 변수에 접근하는 것은 불가능하나 그 역은 가능하다
```

[돌아가기](#목차)

# 3장 자바와 객체 지향

> 추상화란 구체적인 것을 분해해서 관찰자가 관심 있는 특성만 가지고 재조합하는 것
> (구체적인 것을 분해해서 관심 영역(애플리케이션 경계에)에 있는 특성만 가지고 재조합 하는 것 = 모델링)

객체: 세상에 존재하는 유일무이한 사물
클래스: 분류, 집합 같은 속성과 기능을 가진 객체를 총칭하는 집합의 개념

#### 상속: 재사용 + 확장

> 상속은 재사용과 확장으로 이해해야 한다.(ex 분류도로 이해)

상속 관계에서 만족해야 할 문장

- 하위 클래스는 상위 클래스다.

**조직도**의 경우

- 아버지는 할아버지다 ??
- 아들은 아버지다 ??
- 딸은 아버지다 ??

**분류도**

- 포유류는 동물이다.
- 고래는 포유류다.
- 고래는 동물이다.

```java
아버지 영희아빠 = new 딸();
-> 딸을 낳으니 아버지 역할을 하는 영희아빠라 이름 지었다 -> ???

동물 뽀로로 = new 펭귄();
-> 펭귄을 낳으니 동물 역할을 하는 뽀로로라 이름 지었다.
```

> 클래스 명은 분류스럽게, 객체 참조 변수명은 유일무이한 사물처럼 작명해야 한다.

```java
public class 동물 {
    String myClass;

    동물() {
        myclass = "동물";
    }

    void showMe() {
        System.ou.println(myClass);
    }
}

public class 포유류 extends 동물 {
    포유류() {
        myClass = "포유류";
    }
    void showMe() {
        System.ou.println(myClass);
    }
}

public class 조류 extends 동물 {
    조류() {
        myClass = "조류";
    }
    void showMe() {
        System.ou.println(myClass);
    }
}

public class 고래 extends 포유류 {
    고래() {
        myClass = "고래";
    }
    void showMe() {
        System.ou.println(myClass);
    }
}

public class 박쥐 extends 포유류 {
    박쥐() {
        myClass = "박쥐";
    }
    void showMe() {
        System.ou.println(myClass);
    }
}

public class 참새 extends 조류 {
    참새() {
        myClass = "참새";
    }
    void showMe() {
        System.ou.println(myClass);
    }
}

public class 펭귄 extends 조류 {
    펭귄() {
        myClass = "펭귄";
    }
    void showMe() {
        System.ou.println(myClass);
    }
}

조류 bird = new 조류();
bird 라는 단어 자체는 객체보다는 클래스, 즉 분류에 더 가깝다.
조류의 나이는? -> 어색 => 클래스
bird의 나이는? -> 어색 => 클래스

public class Driver01 {
    public static void main(String[] args) {
        동물 animal = new 동물();
        포유류 mammalia = new 포유류();
        조류 bird = new 조류();
        고래 whale = new 고래();
        박쥐 bat = new 박쥐();
        참새 sparrow = new 참새();
        펭귄 penguin = new 펭귄();

        animal.showMe();
        mammalia.showMe();
        whale.showMe();
        bat.showMe();
        sparrow.showMe();
        penguin.showMe();
    }
}

public class Driver02 {
    public static void main(String[] args) {
        동물 animal = new 동물();
        동물 mammalia = new 포유류();
        동물 bird = new 조류();
        동물 whale = new 고래();
        동물 bat = new 박쥐();
        동물 sparrow = new 참새();
        동물 penguin = new 펭귄();

        animal.showMe();
        mammalia.showMe();
        whale.showMe();
        bat.showMe();
        sparrow.showMe();
        penguin.showMe();
    }
}
=> 하위 클래스는 상위 클래스다. == 하위 분류는 상위 분류다.

public class Driver02 {
    public static void main(String[] args) {
        동물[] animal = new 동물[7];
        animals[0] = new 동물();
        animals[1] = new 포유류();
        animals[2] = new 조류();
        animals[3] = new 고래();
        animals[4] = new 박쥐();
        animals[5] = new 참새();
        animals[6] = new 펭귄();
    }

    for(int idx = 0; idx < animal.length; idx++) {
        animals[idx].showMe();
    }
}
```

- 하위 클래스 is a kind of 상위 클래스
- 펭귄 is a kind of 조류 -> 펭귄은 조류의 한 분류다.
- 펭귄 is a kind of 동물 -> 펭귄은 동물의 한 분류다.
- 고래 is a kind of 동물 -> 고래는 동물의 한 분류다.

```
- 객체 지향의 상속은 상위 클래스의 특성을 재사용하는 것이다.
- 객체 지향의 상속은 상위 클래스의 특성을 확장하는 것이다.
- 객체 지향의 상속은 is a kind of 관계를 만족해야 한다.
```

#### 다중 상속과 자바

- 인터페이스: 구현 클래스 is able to 인터페이스
- 해석: 구현 클래스는 인터페이스 할 수 있다.
- 예제: 고래는 헤엄칠 수 있다.

상위 클래스는 하위 클래스에게 속성과 메서드 를 상속해 준다.
인터페이스는 클래스가 '무엇을 할 수 있다'라고 하는 기능을 구현하도록 강제한다.

```java
public class 동물 {
    String myClass;

    동물() {
        myClass = "동물";
    }

    void showMe() {
        System.out.println(myClass);
    }
}

public interface 날수있는 {
    void fly();
}
public interface 헤엄칠수있는 {
    void swim();
}

public class 포유류 extends 동물 {
    포유류() {
        myClass = "포유류";
    }
}

public class 조류 extends 동물 {
    조류() {
        myClass = "조류";
    }
}

public class 고래 extends 포유류 implements 헤엄칠수있는 {
    고래() {
        myClass = "고래";
    }

    @Override
    public void swim() {
        System.out.println(myClass + " 수영 중");
    }
}

public class 박쥐 extends 포유류 implements 날수있는 {
    박쥐() {
        myClass = "박쥐";
    }

    @Override
    public void fly() {
        System.out.println(myClass + "날고있다.");
    }
}


public class Driver {
    public static void main(String[] args) {
        날수있는 날라리1 = new 박쥐();
        날리1.fly();

        날수있는 날라리2 = new 참새();
        날라리2.fly();
    }
}
```

**하위 클래스의 인스턴스가 생성될 때 상위 클래스의 인스턴스도 함께 생성된다.**

**상위 클래스 타입의 객체 참조 변수를 사용하더라도 하위 클래스에서 오버라이딩(재정의)한 메서드가 호출된다.**

```java
class driver {
    public static void main(String[] args) {
        동물[] 동물들 = new 동물[5];

        동물들[0] = new 쥐();
        동물들[1] = new 고양이();
        동물들[2] = new 강아지();

        for(int i = 0; i < 동물들.length; i++) {
            동물들[i].울어보세요();
        }
    }
}

상위 클래스인 동물 클래스에 울어보세요() 메서드를 하위 클래스에서 오버라이딩 한 경우 각 동물들이 하위 클래스 타입에 맞게 울게된다.
```

#### 캡슐화: 정보 은닉

- 상속을 받지 않았다면 객체 멤버는 객체를 생성한 후 객체 참조 변수를 이용해 접근해야 한다.
- 정적 멤버는 클래스명.정적멤버 형식으로 접근하는 것을 권장한다.

[돌아가기](#목차)
