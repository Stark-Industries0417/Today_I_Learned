# 4장 변수

> 변수: 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름

```javascript
result = 10 + 20;
```

##### 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름

##### 변수 이름(식별자)는 값이 아니라 메모리 주소를 기억하고 있음

- 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름 -> 변수 이름(변수명)
- 변수에 저장된 값을 변수 값
- 변수에 값을 저장하는 것을 할당(대입, 저장)
- 변수에 저장된 값을 읽어 들이는 것을 참조

```javascript
var score;
```

다음과 같이 변수 이름 등록하고 값을 저장할 메모리 공간 확보
변수 선언에 의해 확보된 메모리 공간은 자바스크립트 엔진에 의해 undefined라는 값이 암묵적으로 할당되어 초기화 됨

#### 실행 컨텍스트

- 변수 이름 비롯한 모든 식별자는 실행 컨텍스트에 등록
- 자바스크립트 엔진이 소스코드 평가하고 실행하기 위해 필요한 환경 제공
- 코드의 실행 결과를 실제로 관리하는 영역
- 자바스크립트 엔진은 실행 컨텍스트 통해 식별자와 스코프 관리한다.

**ReferenceError**
자바스크립트 엔진에 등록되지 않은 식별자를 참조하려 했을 때 발생하는 에러

#### 변수 선언의 실행 시점과 변수 호이스팅

```javascript
console.log(score); // undefined
var score; // 변수 선언문
```

- 변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점에 실행되는것이 아님
- 런타임 이전 단계에서 실행됨

- 자바스크립트 엔진은 소스코드 한 줄씩 순차 실행하기 앞서 먼저 소스코드 평가 과정 거치면서 소스코드 실행 준비함
- 소스코드 평가 과정에서 엔진은 변수 선언, 모든 선언문을 소스코드에서 찾아내 먼저 실행시킴 그 후 평가과정 끝나면 모든 선언문 제외하고 소스코드를 한 줄씩 순차적으로 실행한다.

> 호이스팅: 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 지칭하는 말

**변수 값의 할당은 소스코드가 순차적으로 실행되는 런타임 시점에 실행 됨**

```javascript
console.log(score);
var score;
score = 80;
console.log(score);
```

```javascript
console.log(score);
score = 80;
var score;
console.log(score); // 80
```

- 변수 호이스팅으로 변수가 선언이 됨
- 그 후 런타임 실행 시점에 변수에 값이 할당되고
- 결과 값으로 80이 나온다.

```javascript
console.log(score);
score = 80;
var score = 50;
console.log(score); // 50
```

- 50값 할당이 제일 마지막에 할당되었으므로 50 출력

##### 가비지 콜렉터(garbage collector)

- 메모리 공간을 주기적 검사하여 더 이상 사용되지 않는 메모리 해제하는 기능
- 어떤 식별자도 참조하지 않는 메모리 공간을 해제하는 기능
- 자바스크립트에 내장되어 있는 가비지 콜렉터를 통해 메모리 누수 방지

##### 값은 식(표현식)이 평가되어 생성된 결과

##### 표현식: 값으로 평가될 수 있는 문(statement) 이다.

=> 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.

##### 문: 프로그램을 구성하는 기본 단위이자 최소 실행 단위

##### 토큰: 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소 의미

=> 키워드, 식별자, 연산자, 리터럴, 세미콜론, 마침표 등

#### 표현식인 문과 표현식이 아닌 문

```javascript
1, 2, 1 + 2, x = 1 + 2 는 모두 표현식
x = 1 + 2 는 표현식이면서 완전한 문이기도 함

var foo = var x; // 변수 선언문은 값으로 평가될 수 없으므로 에러 발생

var foo = x = 100; // 표현식인 문은 값처럼 사용 가능
console.log(foo) // 100
```

# 6장 데이터 타입

```javascript
console.log(10 / 0); // infinity
console.log(10 / -0); // -Infinity

typeof NaN === "number"; // true

12341231231n === BigInt(12341231231); // true
```

##### 일반 문자열 내에서는 줄바꿈 허용되지 않음

```javascript
var str = 'Hello
word.';
// SyntaxError: Invalid or unexpected token
```

#### 심벌 타입

- 변경 불가능한 원시 타입의 값
- 심벌 값은 다른 값과 중복 되지 않는 유일무이한 값
- 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키 만들기 위해 사용

```javascript
var key = Symbol("key");
console.log(typeof key); // symbol

var obj = {};
// 이름이 충돌할 위험이 없는 유일무이한 값인 심벌을 프로퍼티 키로 사용
obj[key] = "value";
console.log(obj[key]); // value

Symbol()에 들어가는 인수는 그저 구분하기 위해 사용하는 것일 뿐
인수 없이 사용해도 중복이 없느 고유한 값을 이용할 수 있다.
```

```javascript
var a = 100;
var b = 100

식별자 a, b 변수가 저장된 주소는 다르고 각각의 변수에 할당된 값의 주소가 같음

ex)
0x111: 식별자 a, 0x123: 100
0x112: 식별자 b, 0x123: 100
```

##### 동적 타이핑

자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정 => 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 잇음

# 7장 연산자

```javascript
for (let i ; i < 10 ; i++) === for(let i ; i < 10 ; ++i)
결과 값 똑같다. i++, ++i 는 평가가 나중에 이뤄지기 때문

```

+, - 단항 연산자는 숫자 타입이 아닌 피연산자에 사용하면 피연산자를 숫자 타입으로 변환하여 반환 => 피연산자 변경하는것은 아니고 부호 반전한 값을 생성해 반환

```javascript
var x = "1";

console.log(+x); // 1 => 문자열을 숫자로 타입 변환
console.log(x); // '1' x는 그대로 이다.

x = true;
console.log(+x); // 1 => 불리언 값을 숫자로 타입 변환
console.log(x); // true

x = false;
console.log(+x); // 0
console.log(x); // false

x = "Hello";
console.log(+x); // NaN(Not a Number) => 문자열을 숫자로 타입 변환할 수 없으므로 NaN 반환
console.log(x); // 'Hello'

-"10" - // -10 => 문자열 숫자로 타입 변환
  -true; // -1
-"Hello"; // => NaN
```

#### 문자열 연결 연산자

**+ 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작, 그 외는 산술 연산자로 동작한다.**

```javascript
'1' + 2; // '12'
1 + '2'; // '12'

true는 1로 타입 변환
1 + true; // 2

1 + false // 1

1 + null // 1 => null은 0으로 타입 변환

1 + undefined; // NaN => undefined 는 숫자로 타입 변환되지 않음

숫자를 string 형으로 빠르게 변환하기 위해 123+'' 이런식으로 쓴다
```

##### 할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가된다.

```
var x;
console.log(x = 10); // 10
```

#### 비교 연산자

| 비교 연산자 | 의미        | 사례    | 설명                     | 부수효과 |
| ----------- | ----------- | ------- | ------------------------ | -------- |
| ==          | 동등 비교   | x == y  | x와 y의 값이 같음        | X        |
| ===         | 일치 비교   | x === y | x와 y의 값과 타입이 같음 | X        |
| !=          | 부동등 비교 | x != y  | x와 y의 값이 다름        | X        |
| !==         | 불일치 비교 | x !== y | x와 y의 값과 타입이 다름 | X        |

**동등 비교(==) 연산자는 좌항과 우항의 피연산자 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교**

```javascript
5 == 5; //true
5 == "5"; // true

"0" == ""; // false
0 == ""; // true
0 == "0"; // true
false == "false"; // false
false == "0"; //true
false == null; //false
false == undefined; // false

동등비교 연산자는 예측하기 어려우므로 사용하지 않는 편이 좋음
```

**일치 비교(===) 연산자는 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환한다.**

```javascript
NaN === NaN // false

NaN은 자신과 일치하지 않는 유일한 값 => 숫자가 NaN인지 조사하려면 빌트인 함수 Number.isNaN 사용

Number.isNaN(NaN); // true
Number.isNaN(10); // false
Number.isNaN(1 + undefined); // true
```

Object.is 메서드

> 예측 가능한 정확한 비교 결과를 반환
> -0 === +0 // true
> Object.is(-0, +0) // false
> Object.is(NaN, NaN) // true

#### 삼항 조건 연산자

```javascript
var x = 2;
var result = x % 2 ? "홀수" : "짝수";
console.log(result);
```

```javascript
var x = 10;
var result = if (x % 2) {result = '홀수';} else {result = '짝수';}; // SyntaxError: Unexpected token if

if ... else 문은 표현식이 아닌 문 => 값처럼 사용할 수 없음
```

**삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식인 문**

#### 논리 연산자

```javascript
true || true; // true
true || false; // true
false || true; // true
false || false; // false

true && true; // true
true && false; // false
false && true; // false
false && false; // false

!true; // false
!false; // true
```

```javascript
!0; // true
!"Hello"; // false
```

**논리합(||) 또는 논리곱(&&) 연산자 표현식의 평가 결과는 불리언 값 아닐 수도 있음**
=> 논리합, 논리곱 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가됨

```javascript
"Cat" && "Dog"; // 'Dog'
```

#### 쉼표 연산자

```javascript
var x, y, z
x = 1, y = 2, z = 3; // 3

function a() {
  var x, y
  return x = 1, y = 2, console.log(x), console.log(x*y), x+y
  => 마지막 피연산자의 평가 결과인 3 반환
}
쉼표 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.
```

#### typeof 연산자

```javascript
typeof null // object
typeof /test/gi //object
typeof function() {} // function

typeof null => 자바스크립트의 첫 번째 버전의 버그
null 타입 확인할 때는 === 연산자 사용
```

#####지수연산자
-5 \*\* 2 // SyntaxError
(-5) \*\* 2 // 25
var num = 5
num \*\*= 2 // 25

#### 그 외의 연산자

| 연산자     | 개요                                                        |
| ---------- | ----------------------------------------------------------- |
| ?.         | 옵셔널 체이닝 연산자                                        |
| ??         | null 병합 연산자                                            |
| delete     | 프로퍼티 삭제                                               |
| new        | 생성자 함수를 호출할 때 사용하여 인스턴스를 생성            |
| instanceof | 좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별 |
| in         | 프로퍼티 존재 확인                                          |

```javascript
옵셔널 체이닝 연산자

const obj = {
  a: {
    b: {
      c: {
        d: 1,
      },
    },
  },
};

const obj2 = {
  a: {
    b: 0,
  },
};

obj.a?.b?.c?.d // 1
obj2.a?.b?.c? // undefined

null 병합 연산자

const a = obj2.a?.b?.c? ?? 10
// 10
const a = obj2.a?.b ?? 10
// 0

앞의 피연산자 값이 null 이면 10 할당
null이 아니면 앞 피연산자 값 할당

delete 연산자
var o = {a: 1};

delete o.a;
console.log(o); // {}
```

# 8장 제어문

##### 제어문: 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행 할 때 사용

##### 블록문: 0개 이상의 문을 중괄호로 묶은 것, 블록문 => 하나의 실행 단위로 취급, 코드 블록 내의 문이 하나뿐이라면 중괄호를 생략할 수 있음

```javascript
// 블록문
{
  var foo = 10;
  console.log(foo); // 10
}

// 제어문
var x = 1;
if (x < 10) {
  x++;
}
```

경우의 수가 세 가지 인 경우 삼항 조건 연산자

```javascript
var num = 2;
var kind = num ? (num > 0 ? "양수" : "음수") : "영";
console.log(kind); // 양수
```

#### Switch 문

> if ... else 문의 조건식은 불리언 값으로 평가되어야 하지만 switch 문의 표현식은 불리언 값보단 문자열이나 숫자 값인 경우가 많다.

```javascript
var month = 11;
var monthName;

switch (month) {
  case 10:
    monthName = "October";
  case 11:
    monthName = "November";
  case 12:
    monthName = "December";
  default:
    monthName = "Invalid month";
}

console.log(monthName); // Invalid month
```

=> **표현식의 평가 결과와 일치하는 case 문으로 이동한 후 switch 문 끝날 때까지 이후의 모든 case 문과 default 문 실행했기 때문 이를 폴스루라 한다.**

> 레이블 문: 식별자가 붙은 문

```javascript
outer: for (var i = 0; i < 3; i++) {
  for (var j = 0; j < 3; j++) {
    console.log(i + j);
    if (i + j === 3) break outer;
  }
}

break outer 로 식별자 outer for 문이 break 하게 된다.
{
  outer: for (var i = 0; i < 3; i++) {
    for (var j = 0; j < 3; j++) {
      console.log(i + j);
      if (i + j === 3) break outer;
    }
  }
}

for문이 표현식이 아닌 문이기 때문에 객체가 아니라 식별자로 판단하고 블록 실행
혼동할 수 있기 때문에 사용하지 않는걸 추천
```

# 9장 타입 변환과 단축 평가

```javascript
var x = 10;

// 명시적 타입 변환
// 숫자를 문자열로 타입 캐스팅
var str = x.toString();
console.log(typeof str, str); // string 10

// x 변수의 값이 변경된 것은 아님
console.log(typeof x, x); // number 10
```

```javascript
var x = 10;

//암묵적 타입 변환, 타입 강제 변환
var str = x + "";
console.log(typeof str, str); // string 10

// x 변수의 값이 변경된 것은 아님
console.log(typeof x, x); // number 10
```

> falsy data: 0, '', false, NaN, undefined, null

##### 숫자 타입으로 변환

```javascript
1 - "1"; // 0
1 * "10"; // 10
1 / "one"; // NaN
"1" > 0; // true

+""; // 0
+"string"; // NaN
+null; // 0

+undefined + // NaN
  {} + // NaN
  [] + // 0
  [10, 20] + // NaN
  function () {}; // NaN
```

##### 단축 평가

| 단축 평가 표현식    | 평가 결과 |
| ------------------- | --------- |
| true \|\| anything  | true      |
| false \|\| anything | anything  |
| true && anything    | anything  |
| false && anything   | false     |

단축 평가를 사용하여 if문 대체

```javascript
var done = true;
var message = "";

if (done) message = "완료";

message = done && "완료";
console.log(message); // 완료

done = false
message = done && '완료' || '미완료 -> 왼쪽에서부터 계산
console.log(message) // 미완료


객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티 참조할 때

var elem = null
var value = elem && elem.value

함수 매개변수에 기본값 설정할 때
undefined 에러 방지

function getStringLength(str) {
  str = str || '';
  return str.length
}

getStringLength(); // 0
getStringLength('hi'); // 2

매개변수의 기본값 설정이 더 낫다
function getStringLength(str = '') {
  return str.length
}
```

##### 옵셔널 체이닝 연산자

```javascript
var elem = null;

elem 이 null 또는 undefined이면 undefined 반환하고, 그렇지 않으면 우항의 프로퍼티 참조 이어감

var value = elem?.value
console.log(value); // undefined

좌항 피연산자가 false 로 평가되는 Falsy 값이여도 null 또는 undefined 가 아니기만 하면 우항의 프로퍼티 참조 이어감

var str = '';
var length = str?.length;
console.log(length); // 0
```

##### null 병합 연산자

좌항의 피연산자가 null 또는 undefined 만인 경우 우항의 피연산자를 반환하고 아니면 좌항의 피연산자를 반환

```javascript
var foo = null ?? "default string";
console.log(foo); // default string
```

# 10장 객체 리터럴

##### 객체타입은 다양한 타입의 값(원시 값 또는 다른 객체)을 하나의 단위로 구성한 복합적인 자료구조

> 자바스크립트는 객체 기반의 프로그래밍 언어, 자바스크립트를 구성하는 거의 모든 것이 객체이다.(원시 값을 제외한 나머지 값(함수, 배열, 정규 표현식 등))

원시 타입은 단 하나의 값만 나타냄

**객체**(클래스와 인스턴스를 포함한 개념)

- 프로퍼티: 객체의 상태를 나타내는 값
- 메서드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작

**인스턴스**

- 클래스에 의해 생성되어 메모리에 저장된 실체
- 클래스는 인스턴스를 생성하기 위한 템플릿 역할

##### 자바스크립트는 프로토타입 기반 객체지향 언어로서 클래스 기반 객체지향 언어와는 달리 다양한 객체 생성 방법 지원

- 객체 리터럴
- Object 생성자 함수
- 생성자 함수
- Object.create 메서드
- 클래스

```javascript
var person = {
  name: "Lee",
  sayHello: function () {
    console.log(`Hello My name is ${this.name}.`);
  },
};

여기서 this는 person을 가리킨다.
this 키워드는 객체 자신을 가리키기 위한 참조변수이다.

console.log(typeof person); // object
console.log(person); // {name: "Lee", sayHello: f}

객체의 중괄호는 블록문이 아니기 때문에 닫는 중괄호에 세미콜론 필요
```

프로퍼티 키: 빈 문자열 포함하는 모든 문자열 또는 심벌 값
프로퍼티 값: 자바스크립트에서 사용할 수 있는 모든 값

> 프로퍼티 키는 자바스크립트에서 사용 가능한 유효한 이름인 경우 따옴표 생략 가능하다
> => 식별자 네이밍 규칙 따르지 않는 이름에는 따옴표 사용해야 함

```javascript
var foo = {
  0: 1,
  1: 2,
  2: 3,
};

console.log(foo); // {0: 1, 1: 2, 2: 3}

프로퍼티 키에 문자열이나 심벌 값 외의 값 사용하면 암묵적 타입 변환 통해 문자열이 됨(따옴표가 붙지 않아도 내부적으로 문자열로 변환된다.)


var foo = {
  name: 'Lee',
  name: 'kim',
};

console.log(foo); // {name: "kim"}
프로퍼티 키 중복 선언하면 나중에 선언한 프로퍼티로 덮어씌어 진다.
```

```javascript
var person = {
  'last-name': 'Lee',
  name: "Lee",
  1: 10
};

console.log(person.name);
console.log(person["name"]);

대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 따옴표로 감싸야한다.

객체에 존재하지 않는 프로퍼티에 접근하면 undefined 반환한다.
ReferenceError 발생하지 않음

console.log(person.age) // undefined


프로퍼티 키가 식별자 네이밍 규칙을 준수하는 이름 => 마침표 표기법, 대괄호 표기법 모두 사용 가능

네이밍 규칙 준수하지 않으면 => 대괄호 표기법만 사용가능

person.'last-name'; // SyntaxError
person.last-name // 브라우저 환경: NaN, Node.js 환경: ReferenceError: name is not defined

브라우저 환경
-> person.last 평가 => undefined 로 평가
-> person.last-name == undefined - name(식별자로 해석)
-> 전역 변수 name은 전역 객체인 window의 프로퍼티으로 존재한다.
-> name == window.name(기본값은 빈 문자열)
=> undefined - '' 으로 해석되어 NaN 발생

Node.JS 환경
-> name 이라는 식별자가 없으므로 ReferenceError: name is not defined 에러 발생 된다.

person[last-name]; // ReferenceError: last is not defined
person['last-name']; // Lee

// 프로퍼티 키가 숫자로 이뤄진 문자열인 경우 따옴표 생략 가능
person.1 // SyntaxError: unexpected number
person.'1' // SyntaxError: Unexpected string
person[1]; // 10
person['1'] // 10

```

#### 프로퍼티 동적 생성

```javascript
var person = {
  name: "Lee",
};

person.age = 20;

console.log(person); // {name: "Lee", age: 20}

프로퍼티 삭제

person.address 프로퍼티가 없어도 에러가 생기지 않는다.
```

#### 프로퍼티 축약 표현

```javascript
var x = 1,
  y = 2;

var obj = {
  x: x,
  y: y,
};

console.log(obj); // {x: 1, y: 2}

const obj = { x, y };

console.log(obj); // {x: 1, y: 2}
```

#### 계산된 프로퍼티 이름

```javascript
var prefix = "prop";
var i = 0;

var obj = {};
obj[prefix + "-" + ++i] = i;
obj[prefix + "-" + ++i] = i;
obj[prefix + "-" + ++i] = i;

console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}

obj = {
  [`${prefix} - ${++i}`]: i
  [`${prefix} - ${++i}`]: i
  [`${prefix} - ${++i}`]: i
}

console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}
```

### 메서드 축약표현

```javascript
const obj = {
    name: "Lee",
    sayHi: function() {
        console.log(`Hi ${this.name}`);
    }
}
console.dir(obj)

Object
name: "Lee"
sayHi: ƒ ()
  arguments: null
  caller: null
  length: 0
  name: "sayHi"
prototype:
  constructor: ƒ ()
  [[Prototype]]: Object
[[FunctionLocation]]: VM376:3
[[Prototype]]: ƒ ()
[[Scopes]]: Scopes[2]
[[Prototype]]: Object


const obj2 = {
    name: 'Lee',
    sayHi() {
        console.log(`Hi ${this.name}`);
    }
};
console.dir(obj2);

Object
name: "Lee"
sayHi: ƒ sayHi()
  length: 0
  name: "sayHi"
  arguments: (...)
  caller: (...)
[[FunctionLocation]]: VM658:3
[[Prototype]]: ƒ ()
[[Scopes]]: Scopes[2]
[[Prototype]]: Object

const a = new obj.sayHi();
Hi undefined

const b = new obj2.sayHi();
Uncaught TypeError: obj2.sayHi is not a constructor
    at <anonymous>:1:11

메시지 축약 사용한 obj2의 sayHi 는 prototype 가 없어서 생성자 함수로 생성할 수 없다.
```
