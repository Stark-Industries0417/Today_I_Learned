> [!info] 생성자의 역할을 대신 해 주는 함수를 팩토리 함수라 한다.

## 팩토리 함수를 사용했을 때의 이점
- 생성자와 다르게 객체가 생성되는 방법과 아규먼트로 무엇이 필요한지에 대한 설명을 함수의 이름으로 남길 수 있다. 
	- ArrayList(3) -> 3이 의미하는 것이 새로 생성하는 리스트의 첫 요소인지 리스트의 크기인지 알 수 없다. => ArrayList.withSize(3) 과 같이 사용하면 이해하기 쉽다.
- 생성자와 다르게, 함수가 원하는 형태의 타입을 리턴할 수 있다. 
	- 인터페이스 뒤에 실제 객체의 구현을 숨길 때 유용하게 사용할 수 있다.
		- listOf는 List 인터페이스를 리턴한다.
		- 인터페이스를 리턴한 것이므로, 인터페이스만 지켜서 만들어진다면 어떤 클래스라도 잘 동작할 것이라는 보증이 있다. 
- 생성자와 다르게, 호출될 때마다 새 객체를 만들 필요가 없다.
	- 팩토리 함수를 사용해 싱글턴을 구현할 수 있다.
	- 최적화를 위해 캐싱 메커니즘을 사용할 수도 있다.
- 팩토리 함수는 아직 존재하지 않는 객체를 리턴할 수 있다.
	- 어노테이션 처리를 기반으로 하는 라이브러리에서 팩토리 함수를 많이 사용한다.
	이를 활용해 프로젝트를 빌드하지 않고도 앞으로 만들어질 객체를 사용하거나, 프록시를 통해 만들어지는 객체를 사용할 수 있다.
- 객체 외부에 팩토리 함수를 만들면, 가시성을 원하는 대로 제어할 수 있다.
	- 톱레벨 팩토리 함수를 같은 파일 또는 같은 모듈에서만 접근하게 만들 수 있다.
- 팩토리 함수는 인라인으로 만들 수 있으며, 그 파라미터들을 reified로 만들 수 있다.
- 팩토리 함수는 생성자로 만들기 복잡한 객체도 만들 수 있다.
- 생성자는 즉시 슈퍼클래스 또는 기본 생성자를 호출해야 한다. 하지만 팩토리 함수는 원하는 때에 생성자를 호출할 수 있다.
### 팩토리 함수의 종류
1. [[companion 객체 팩토리 함수]]
2. [[확장 팩토리 함수]]
3. [[톱레벨 팩토리 함수]]
4. [[가짜 생성자]]
5. [[팩토리 클래스의 메서드]]

> 팩토리 함수를 정의하는 가장 일반적인 방법은 companion 객체를 사용하는 것이다.

#effective 