## inline 한정자 사용시 장점
1. 타입 아규먼트에 reified 한정자를 붙여 사용할 수 있다.
2. 함수 타입 파라미터를 가진 함수가 훨씬 빠르게 동작한다.
	- 함수 호출과 리턴을 위해 점프하는 과정과 백스택을 추적하는 과정이 없기 때문
	- JVM에선 람다를 익명 클래스 또는 일반 클래스를 기반으로 함수를 객체로 만들어 내기 때문에 
	  고차함수에 inline을 붙이게 되면 빠르다.
3. 비지역 리턴을 사용할 수 있다.
## inline 한정자의 비용
> [!info] 인라인 함수는 재귀적으로 동작할 수 없다.

``` kotlin
inline fun a() { b() }
inline fun b() { c() }
inline fun c() { a() }

재귀적으로 사용시 무한하게 대체되는 문제가 발생한다. 이런 문제는 intelij가
오류로 잡아주지 못하므로 굉장히 위험하다
```
- public 인라인 함수 내부에선 private과 internal 가시성을 가진 함수와 프로퍼티를 사용할 수 없다.
	=> 인라인 함수는 구현을 숨길 수 없으므로 클래스에 거의 사용되지 않는 것이다.
- 코드가 기하급수적으로 증가할수 있어 위험하다.

## 정리
인라인 함수가 사용되는 주요 사례
- print 함수처럼 매우 많이 사용되는 경우
- filterIsInstance 함수처럼 타입 아규먼트로 reified 타입을 전달받는 경우
- 함수 타입 파라미터를 갖는 톱 레벨 함수를 정의해야 하는 경우
	- 헬퍼함수(map, filter, flatMap, joinToString 등)
	- 스코프 함수(also, apply, let 등)
	- 톱 레벨 유틸리티 함수(repeat, run, with)

#effective 