## 목차
- [이름](#이름)
    - [축약어](#축약어)
    - [Util](#util)
- [동사](#동사)
    - [get vs find](#get-vs-find)
    - [get](#get)
- [롬복](#롬복)
    - [getter setter](#getter-setter)
- [가독성](#가독성)
    - [주석](#주석)
    - [Optional](#optional)
    - [Collection.Map](#collectionmap)
- [관습](#관습)
    - [start end](#start-end)
- [객체의 종류](#객체를-만들-때의-고민)
    - [VO(Value Object)](#vovalue-object)
    - [DTO(Data Transfer Object)](#dtodata-transfer-object)
    - [Entity](#entity)
    - [디미터 법칙](#디미터-법칙)
- [행동](#행동)
    - [duck typing](#duck-typing)
- [순환 참조](#순환-참조)
    - [순환 참조가 부자연스로운 이유](#순환-참조가-부자연스로운-이유)
    - [간접 참조로 해결](#간접-참조로-해결)

## 이름
### 축약어
### 축약어를 대문자로 표현하지 않는다.
**일반 명사과 같은 취급**
축약어 예시 : OIDC, ID, LDAP, REST, API, IP

``` java
권장
private String userId;
private String oidcId;
private String ldapId;
private String restApi;
private String ip;
public String getLdapId();
public class ApiClient {}

BAD
private String userID;
private String oidcID;
private String ldapID;
private String REST_API;
private String oidcID;
private String iP;
public String getLDAPID();
public class APIClient {}

전부 대문자로 쓴다라는 룰을 사용하면 상수(ex. LDAP_ID)와 표기가 헷갈린다.
```
[돌아가기](#목차)


### Util
**유의미한 단어 사용**
Util 이라는 이름 하에 모든 static 메서드가 모이게 된다.

[돌아가기](#목차)



## 동사
### get vs find
구분해서 사용할 것

get 
- 항상 인스턴스를 돌려받는다는 의미
- return type이 T 인 경우 (일반적으로 데이터가 없을 시 exception을 throw 한다.)

find
- return type이 Optional<T>인 경우

[돌아가기](#목차)

### get
 
get은 내가 갖고있는 멤버 변수를 그대로 돌려준다는 의미가 크다.   
**어떤 결과를 계산해서 찾아오라는 지시가 아니다.**

```java
권장
class Products {
    public int sumPrice() {
        return this.products.stream().mapToLong(Product::getPrice).sum();
    }
}

BAD
class Products {
    public int getSumPrice() {
        return this.products.stream().mapToLong(Product::getPrice).sum();
    }
}
```

[돌아가기](#목차)

## 롬복
### getter setter
getter setter를 남발하지 말 것
- 캡슐화를 망치는 주범
- 사실상 public 멤버 변수이다.
- **객체를 수동적이게 만든다.**

``` java
@Getter
@Setter
class User {
    enum Status {ACTIVE, INACTIVE}

    private long id;
    private String name;
    private Status status;
    private long lastLoginTimestamp;
}

class UserManager {
    // user 객체가 수동적이다.
    // 객체가 데이터를 저장하고 보여주는 것 외에는 일을 하지 않는다.
    public void doSomething(User user) {
        user.setStatus(Status.ACTIVE)
        user.setLastLoginTimestamp(Clock.systemUTC().millis());
    }
}
```

**객체를 조금 더 능동적이게 만들기**
``` java
객체한테 일을 시켜야 한다.

class User {
    enum Status {ACTIVE, INACTIVE}

    private long id;
    private String name;
    private Status status;
    private long lastLoginTimestamp;

    public void inactive() {
        this.status = Status.INACTIVE;
    }

    public void login(Clock clock) {
        this.lastLoginTimestamp = clock.millis();
    }
}

class UserManager {
    public void doSomething(User user) {
        user.inactive();
        user.login(Clock.systemUTC());
    }
}
```

> TDA(Tell don't ask) 원칙   
객체에게 물어보지 말고 일을 시켜라

[돌아가기](#목차)

## 가독성

### 주석
- 주석은 정말 필요할 때만 사용할 것
- 읽기 좋은 코드는 그 자체만으로도 잘 읽힌다.
- 주석을 다는 것보단 그 내용을 유의미한 의미를 가진 메서드로 분리하는 것이 낫다.

``` java
public class WebsocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        // 클라이언트 -> 서버의 메시지 수신 API Prefix 설정
        registry.setApplicationDestinationPrefixes("/application");
    }
}
```
유의미한 의미를 가진 메서드로 분리하라

``` java
public class WebsocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        // 클라이언트 -> 서버의 메시지 수신 API Prefix 설정
        setServerApiPrefix(registry, "/application");
    }

    private void setServerApiPrefix(MessageBrokerRegistry registry, String prefix) {
        registry.setApplicationDestinationPrefixes(prefix);
    }
}
```

[돌아가기](#목차)

### Optional
Optional을 자주 사용하라
코드의 완성도를 높이고 런타임 에러(NPE)를 줄여줍니다.

[돌아가기](#목차)

### Collection.Map
- 가급적이면 일급 클래스로 만들어라
- 사용하더라도 지정된 scope 밖을 넘나들지 말 것

``` java
Map<Long, List<LectureComment>> userIdToLectureComments = new HashMap<>();
```

[돌아가기](#목차)

## 관습
### start end
range 는 [start, end) 시작 부분은 포함하고 끝 부분은 제외시킨다.

1) Java IntStream
``` java
public static IntStream range(int startInclusive, int endExclusive) {
    if(startInclusive >= endExclusive) {
        return empty();
    } else {
        return StreamSupport.intStream(
            new Streams.RangeIntSpliterator(startInclusive, endExclusive, false), false
        );
    }
}
```

### 더 알아볼 만한 주제
1. 검증이 필요할 때: verify vs validate vs check vs is
2. 코드 스타일: 구글 코드 스타일 가이드 참고
3. 단어 조합은 3개 이하로

[돌아가기](#목차)

## 객체의 종류

### VO(Value Object)

> VO   
VO는 불변해야 하며, 이는 동일하게 생성된 두 VO는 영원히 동일한 상태임을 유지되어야 함을 의미   
또한 VO는 잘못된 상태로는 만들어 질 수 없다. 따라서 인스턴스화 된 VO는 항상 유효하므로 버그를 줄이는데 유용하다.

``` java
class UserInfo {
    private final long id;
    private final String username;
    private final String email;

    public UserInfo(long id, String username, String email) {
        this.id = id;
        this.username = username;
        this.email = email;
    }
}

=> 변할 수 없는 객체
```

VO 객체는 항상 유효하므로 유효한지 체크해줘야 한다.
``` java
class UserInfo {
    private final long id;
    private final String username;
    private final String email;

    public UserInfo(long id, String username, String email) {
        assert id > 0;
        assert StringUtils.isNotEmpty(username);
        assert EmailValidator.isValid(email);

        this.id = id;
        this.username = username;
        this.email = email;
    }
}
```
**생성자는 가급적 두개의 역할만 해야한다**   
값 검증, 값 할당

[돌아가기](#목차)

### DTO(Data Transfer Object)

> DTO는 상태를 보호하지 않으며 모든 속성을 노출하므로 getter와 setter가 필요 없다.   
이는 public 속성으로 충분하다는 뜻이다.

DTO는 데이터를 주고받을 때 변수들을 파라미터로 하나하나 나열하기 힘드니까   
하나로 묶어 전송하는 객체이다.

[돌아가기](#목차)

### Entity
- 유일한 식별자가 있다.
- 수명 주기가 있으며
- 쓰기 모델 **저장소에 저장**함으로써 지속성을 가지며 나중에 저장소에 불러올 수 있다.

``` java
@Entity
@Table(name = "user")
public class User {
    @EmbeddedId
    @Column(updatable = false, nullable = false)
    public UserId id;

    public String username;

    @Embedded
    public Password password;
    @Column(updatable = false, nullable = false)

    public String email;

    public void changePassword(String before, String after) {
        // ...
    }
}

이 엔티티 클래스는
이 클래스로 만들어진 객체는 식별자도 있고 
영속성 컨텍스트에서 수명주기가 관리되니까 엔티티이다.
```

> 엄밀히 말하면 Entity는 DB와 전혀 관계가 없다.   
Entity는 DB와 연동 된다는 통념이 전반적으로 깔린 이유는 JPA @Entity 어노테이션이 만들어낸 거대혼 오해인 것 같다.   
PO(Persistence Object) 라고 부르는게 맞다고 생각한다.

#### 객체를 만들 때의 고민
객체의 종류에는 3종류만 있는 것이 아니며, 완벽한 분류는 어렵다.
- VO이면서 Entity 일 수 있고
- DTO이면서 PO 일 수 있다.
- 셋 다 아닐 수도 있다.

사실 분류보단 이 고민이 더 중요하다
- 어떤 값을 불변으로 만들 것인지
- 어떤 인터페이스를 노출할 것 인지
- 어떤 메서드를 public으로 선언할 것인지

DAO(Data Access Object)   
요즘 날엔 사실상 Repository와 동치가 되면서 거의 사용되지 않는 용어   
단어만 보면 DTO와 비슷하나 크게 상관 없다.

[돌아가기](#목차)

### 디미터 법칙
최소 지식의 법칙

**모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다.**

``` java
class ComputerManager {
    public void printSpec(Computer computer) {
        long size = 0;
        for (int i = 0; i < computer.getDisks().size(); i++) {
            size += computer.getDisks().get(i).getSize();
        }
        System.out.println(size);
    }
}
=> 디미터 법칙을 위배

컴퓨터 관리자가 컴퓨터의 내부 구현을 너무 깊게 알고 있기 때문이다.
=> computer.getDisks().get(i).getSize();

컴퓨터 관리자는 모듈의 내부 사정까지는 알아서는 안된다.

class ComputerManager {
    public void printSpec(Computer computer) {
        System.out.println(computer.getDiskSize());
    }
}
객체 내부를 체이닝으로 줄줄히 들어가서 뭔가 조작한다면 디미터 법칙 위반이다.

바로 위 코드도 좋은 코드가 아니다 TDA원칙을 지키지 않았기 때문

디스크 용량이 얼마인지 물어봐서 출력하지 말고

public void printSpec(Computer computer) {
    computser.printSpec();
}

=> 디스크 용량을 출력시키는 일을 시켜야한다.
```

[돌아가기](#목차)

## 행동

자동차 클래스를 만들어야 한다면

1. 데이터 위주의 사고
자동차는 바퀴, 프레임, 엔진, 방향, 속도 값들을 갖고 있어야 곘다.

``` java
class Car {
    private Frame frame;
    private Engine engine;
    private List<Wheel> wheels;
    private Direction direction;
    private Speed speed;
}
=> struct를 만든 것
```

2. 행동 위주의 사고
- 자동차는 달릴 수 있어야 하고
- 속도를 조절할 수 있어야 하고
- 방향을 바꿀 수 있어야 한다.

``` java
class Car {
    public void drive() {}
    public void changeDirection() {}
    public void accelerate(Speed speed) {}
    public void decelerate(Speed speed) {}
}
=> class를 만든 것
```

**행동 위주의 사고를 하는 것이 객체지향적일 확률이 높다**

[돌아가기](#목차)

### duck typing
=> 행동이 같다면 같은 클래스로 부르겠다.

> 덕 타이핑 이라는 용어는 다음과 같이 표현될 수 있는 덕 테스트에서 유래했다.   
만약 어떤 새가 오리처럼 걷고, 헤엄치고, 꽥꽥거리는 소리를 낸다면   
나는 그 새를 오리라고 부를 것이다.

[돌아가기](#목차)

## 순환 참조

순환 참조, 양방향 참조를 만들지 말 것
> 순환 참조는 논리적으로 여러 도메인에 존재하며 간혹 설계에도 필요하지만   
순환 참조를 유지하는 데는 신중을 기해야 한다.

### 순환 참조가 부자연스로운 이유
1. 순환 참조를 넘어 순환 의존성 자체가 결합도를 높이는 원인이 된다.
2. 순환참조 때문에 Serialize가 불가해진다.

``` java
class User {
    private long id;
    private String username;
    private List<Feed> feeds;
}

class Feed {
    private long id;
    private String content;
    private User writer;
}

User user = User.builder().id(1).username("boo").build();
Feed feed1 = Feed.builder().id(1).wirter(user).content("foo").build();
Feed feed2 = Feed.builder().id(2).wirter(user).content("bar").build();
Feed feed3 = Feed.builder().id(3).wirter(user).content("baz").build();
user.setFeeds(Arrays.asList(feed1, feed2, feed3));

=> 에러 발생
```

[돌아가기](#목차)

### 간접 참조로 해결
**차라리 Id로 필요할 때마다 찾아오는게 낫다.**

``` java
class User {
    private long id;
    private String username;
    private List<Feed> feeds;
}

class Feed {
    private long id;
    private String content;
    // id를 기록하고 필요할 때마다 repository에서 갖고 오는것이 낫다.
    private long writerId;
}
```

컴포넌트 분리로 해결
A, B 클래스가 서로 순환 참조한다면 참조하는 부분을 따로 클래스로 만들어 분리한다.

### 더 알아볼 만한 주제
1. 항상 하면 좋은 고민
- final 이어야 할까?
- 이름은 뭘로하는게 좋을까?
2. VO의 변경자
비밀번호 변경 메서드를 새로운 VO를 반환하는 메서드가 되어야 한다.
- 새로운 VO를 반환한다.
- VO의 변경자 이름(e.g changePassword < withNewPassword)   

VO의 변경 메서드를 일반 변경 메서드와 구분하기 위해 메서드의 이름을 전치사로 시작하는 경우도 있다.

[돌아가기](#목차)