## 목차
- [이름](#이름)
    - [축약어](#축약어)
    - [Util](#util)
- [동사](#동사)
    - [get vs find](#get-vs-find)
    - [get](#get)
- [롬복](#롬복)
    - [getter setter](#getter-setter)
- [가독성](#가독성)
    - [주석](#주석)
    - [Optional](#optional)
    - [Collection.Map](#collectionmap)
- [관습](#관습)
    - [start end](#start-end)
- [객체의 종류](#객체를-만들-때의-고민)
    - [VO(Value Object)](#vovalue-object)
    - [DTO(Data Transfer Object)](#dtodata-transfer-object)
    - [Entity](#entity)
    - [디미터 법칙](#디미터-법칙)
- [행동](#행동)
    - [duck typing](#duck-typing)
- [순환 참조](#순환-참조)
    - [순환 참조가 부자연스로운 이유](#순환-참조가-부자연스로운-이유)
    - [간접 참조로 해결](#간접-참조로-해결)
- [SOLID](#solid)
    - [Single response](#single-response)
    - [Open-Closed](#open-closed)
    - [리스코프 치환 원칙](#리스코프-치환-원칙)
    - [Interface-Segregation](#interface-segregation)
    - [Dependency inversion](#dependency-inversion)
- [의존성 조언](#의존성-조언)
    - [변하는 값은 주입 받아라](#변하는-값은-주입-받아라)
    - [변하는 값을 추상화 시켜라](#변하는-값을-추상화-시켜라)


## 이름
### 축약어
### 축약어를 대문자로 표현하지 않는다.
**일반 명사과 같은 취급**
축약어 예시 : OIDC, ID, LDAP, REST, API, IP

``` java
권장
private String userId;
private String oidcId;
private String ldapId;
private String restApi;
private String ip;
public String getLdapId();
public class ApiClient {}

BAD
private String userID;
private String oidcID;
private String ldapID;
private String REST_API;
private String oidcID;
private String iP;
public String getLDAPID();
public class APIClient {}

전부 대문자로 쓴다라는 룰을 사용하면 상수(ex. LDAP_ID)와 표기가 헷갈린다.
```
[돌아가기](#목차)


### Util
**유의미한 단어 사용**
Util 이라는 이름 하에 모든 static 메서드가 모이게 된다.

[돌아가기](#목차)



## 동사
### get vs find
구분해서 사용할 것

get 
- 항상 인스턴스를 돌려받는다는 의미
- return type이 T 인 경우 (일반적으로 데이터가 없을 시 exception을 throw 한다.)

find
- return type이 Optional<T>인 경우

[돌아가기](#목차)

### get
 
get은 내가 갖고있는 멤버 변수를 그대로 돌려준다는 의미가 크다.   
**어떤 결과를 계산해서 찾아오라는 지시가 아니다.**

```java
권장
class Products {
    public int sumPrice() {
        return this.products.stream().mapToLong(Product::getPrice).sum();
    }
}

BAD
class Products {
    public int getSumPrice() {
        return this.products.stream().mapToLong(Product::getPrice).sum();
    }
}
```

[돌아가기](#목차)

## 롬복
### getter setter
getter setter를 남발하지 말 것
- 캡슐화를 망치는 주범
- 사실상 public 멤버 변수이다.
- **객체를 수동적이게 만든다.**

``` java
@Getter
@Setter
class User {
    enum Status {ACTIVE, INACTIVE}

    private long id;
    private String name;
    private Status status;
    private long lastLoginTimestamp;
}

class UserManager {
    // user 객체가 수동적이다.
    // 객체가 데이터를 저장하고 보여주는 것 외에는 일을 하지 않는다.
    public void doSomething(User user) {
        user.setStatus(Status.ACTIVE)
        user.setLastLoginTimestamp(Clock.systemUTC().millis());
    }
}
```

**객체를 조금 더 능동적이게 만들기**
``` java
객체한테 일을 시켜야 한다.

class User {
    enum Status {ACTIVE, INACTIVE}

    private long id;
    private String name;
    private Status status;
    private long lastLoginTimestamp;

    public void inactive() {
        this.status = Status.INACTIVE;
    }

    public void login(Clock clock) {
        this.lastLoginTimestamp = clock.millis();
    }
}

class UserManager {
    public void doSomething(User user) {
        user.inactive();
        user.login(Clock.systemUTC());
    }
}
```

> TDA(Tell don't ask) 원칙   
객체에게 물어보지 말고 일을 시켜라

[돌아가기](#목차)

## 가독성

### 주석
- 주석은 정말 필요할 때만 사용할 것
- 읽기 좋은 코드는 그 자체만으로도 잘 읽힌다.
- 주석을 다는 것보단 그 내용을 유의미한 의미를 가진 메서드로 분리하는 것이 낫다.

``` java
public class WebsocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        // 클라이언트 -> 서버의 메시지 수신 API Prefix 설정
        registry.setApplicationDestinationPrefixes("/application");
    }
}
```
유의미한 의미를 가진 메서드로 분리하라

``` java
public class WebsocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        // 클라이언트 -> 서버의 메시지 수신 API Prefix 설정
        setServerApiPrefix(registry, "/application");
    }

    private void setServerApiPrefix(MessageBrokerRegistry registry, String prefix) {
        registry.setApplicationDestinationPrefixes(prefix);
    }
}
```

[돌아가기](#목차)

### Optional
Optional을 자주 사용하라
코드의 완성도를 높이고 런타임 에러(NPE)를 줄여줍니다.

[돌아가기](#목차)

### Collection.Map
- 가급적이면 일급 클래스로 만들어라
- 사용하더라도 지정된 scope 밖을 넘나들지 말 것

``` java
Map<Long, List<LectureComment>> userIdToLectureComments = new HashMap<>();
```

[돌아가기](#목차)

## 관습
### start end
range 는 [start, end) 시작 부분은 포함하고 끝 부분은 제외시킨다.

1) Java IntStream
``` java
public static IntStream range(int startInclusive, int endExclusive) {
    if(startInclusive >= endExclusive) {
        return empty();
    } else {
        return StreamSupport.intStream(
            new Streams.RangeIntSpliterator(startInclusive, endExclusive, false), false
        );
    }
}
```

### 더 알아볼 만한 주제
1. 검증이 필요할 때: verify vs validate vs check vs is
2. 코드 스타일: 구글 코드 스타일 가이드 참고
3. 단어 조합은 3개 이하로

[돌아가기](#목차)

## 객체의 종류

### VO(Value Object)

> VO   
VO는 불변해야 하며, 이는 동일하게 생성된 두 VO는 영원히 동일한 상태임을 유지되어야 함을 의미   
또한 VO는 잘못된 상태로는 만들어 질 수 없다. 따라서 인스턴스화 된 VO는 항상 유효하므로 버그를 줄이는데 유용하다.

``` java
class UserInfo {
    private final long id;
    private final String username;
    private final String email;

    public UserInfo(long id, String username, String email) {
        this.id = id;
        this.username = username;
        this.email = email;
    }
}

=> 변할 수 없는 객체
```

VO 객체는 항상 유효하므로 유효한지 체크해줘야 한다.
``` java
class UserInfo {
    private final long id;
    private final String username;
    private final String email;

    public UserInfo(long id, String username, String email) {
        assert id > 0;
        assert StringUtils.isNotEmpty(username);
        assert EmailValidator.isValid(email);

        this.id = id;
        this.username = username;
        this.email = email;
    }
}
```
**생성자는 가급적 두개의 역할만 해야한다**   
값 검증, 값 할당

[돌아가기](#목차)

### DTO(Data Transfer Object)

> DTO는 상태를 보호하지 않으며 모든 속성을 노출하므로 getter와 setter가 필요 없다.   
이는 public 속성으로 충분하다는 뜻이다.

DTO는 데이터를 주고받을 때 변수들을 파라미터로 하나하나 나열하기 힘드니까   
하나로 묶어 전송하는 객체이다.

[돌아가기](#목차)

### Entity
- 유일한 식별자가 있다.
- 수명 주기가 있으며
- 쓰기 모델 **저장소에 저장**함으로써 지속성을 가지며 나중에 저장소에 불러올 수 있다.

``` java
@Entity
@Table(name = "user")
public class User {
    @EmbeddedId
    @Column(updatable = false, nullable = false)
    public UserId id;

    public String username;

    @Embedded
    public Password password;
    @Column(updatable = false, nullable = false)

    public String email;

    public void changePassword(String before, String after) {
        // ...
    }
}

이 엔티티 클래스는
이 클래스로 만들어진 객체는 식별자도 있고 
영속성 컨텍스트에서 수명주기가 관리되니까 엔티티이다.
```

> 엄밀히 말하면 Entity는 DB와 전혀 관계가 없다.   
Entity는 DB와 연동 된다는 통념이 전반적으로 깔린 이유는 JPA @Entity 어노테이션이 만들어낸 거대혼 오해인 것 같다.   
PO(Persistence Object) 라고 부르는게 맞다고 생각한다.

#### 객체를 만들 때의 고민
객체의 종류에는 3종류만 있는 것이 아니며, 완벽한 분류는 어렵다.
- VO이면서 Entity 일 수 있고
- DTO이면서 PO 일 수 있다.
- 셋 다 아닐 수도 있다.

사실 분류보단 이 고민이 더 중요하다
- 어떤 값을 불변으로 만들 것인지
- 어떤 인터페이스를 노출할 것 인지
- 어떤 메서드를 public으로 선언할 것인지

DAO(Data Access Object)   
요즘 날엔 사실상 Repository와 동치가 되면서 거의 사용되지 않는 용어   
단어만 보면 DTO와 비슷하나 크게 상관 없다.

[돌아가기](#목차)

### 디미터 법칙
최소 지식의 법칙

**모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다.**

``` java
class ComputerManager {
    public void printSpec(Computer computer) {
        long size = 0;
        for (int i = 0; i < computer.getDisks().size(); i++) {
            size += computer.getDisks().get(i).getSize();
        }
        System.out.println(size);
    }
}
=> 디미터 법칙을 위배

컴퓨터 관리자가 컴퓨터의 내부 구현을 너무 깊게 알고 있기 때문이다.
=> computer.getDisks().get(i).getSize();

컴퓨터 관리자는 모듈의 내부 사정까지는 알아서는 안된다.

class ComputerManager {
    public void printSpec(Computer computer) {
        System.out.println(computer.getDiskSize());
    }
}
객체 내부를 체이닝으로 줄줄히 들어가서 뭔가 조작한다면 디미터 법칙 위반이다.

바로 위 코드도 좋은 코드가 아니다 TDA원칙을 지키지 않았기 때문

디스크 용량이 얼마인지 물어봐서 출력하지 말고

public void printSpec(Computer computer) {
    computser.printSpec();
}

=> 디스크 용량을 출력시키는 일을 시켜야한다.
```

[돌아가기](#목차)

## 행동

자동차 클래스를 만들어야 한다면

1. 데이터 위주의 사고
자동차는 바퀴, 프레임, 엔진, 방향, 속도 값들을 갖고 있어야 곘다.

``` java
class Car {
    private Frame frame;
    private Engine engine;
    private List<Wheel> wheels;
    private Direction direction;
    private Speed speed;
}
=> struct를 만든 것
```

2. 행동 위주의 사고
- 자동차는 달릴 수 있어야 하고
- 속도를 조절할 수 있어야 하고
- 방향을 바꿀 수 있어야 한다.

``` java
class Car {
    public void drive() {}
    public void changeDirection() {}
    public void accelerate(Speed speed) {}
    public void decelerate(Speed speed) {}
}
=> class를 만든 것
```

**행동 위주의 사고를 하는 것이 객체지향적일 확률이 높다**

[돌아가기](#목차)

### duck typing
=> 행동이 같다면 같은 클래스로 부르겠다.

> 덕 타이핑 이라는 용어는 다음과 같이 표현될 수 있는 덕 테스트에서 유래했다.   
만약 어떤 새가 오리처럼 걷고, 헤엄치고, 꽥꽥거리는 소리를 낸다면   
나는 그 새를 오리라고 부를 것이다.

[돌아가기](#목차)

## 순환 참조

순환 참조, 양방향 참조를 만들지 말 것
> 순환 참조는 논리적으로 여러 도메인에 존재하며 간혹 설계에도 필요하지만   
순환 참조를 유지하는 데는 신중을 기해야 한다.

### 순환 참조가 부자연스로운 이유
1. 순환 참조를 넘어 순환 의존성 자체가 결합도를 높이는 원인이 된다.
2. 순환참조 때문에 Serialize가 불가해진다.

``` java
class User {
    private long id;
    private String username;
    private List<Feed> feeds;
}

class Feed {
    private long id;
    private String content;
    private User writer;
}

User user = User.builder().id(1).username("boo").build();
Feed feed1 = Feed.builder().id(1).wirter(user).content("foo").build();
Feed feed2 = Feed.builder().id(2).wirter(user).content("bar").build();
Feed feed3 = Feed.builder().id(3).wirter(user).content("baz").build();
user.setFeeds(Arrays.asList(feed1, feed2, feed3));

=> 에러 발생
```

[돌아가기](#목차)

### 간접 참조로 해결
**차라리 Id로 필요할 때마다 찾아오는게 낫다.**

``` java
class User {
    private long id;
    private String username;
    private List<Feed> feeds;
}

class Feed {
    private long id;
    private String content;
    // id를 기록하고 필요할 때마다 repository에서 갖고 오는것이 낫다.
    private long writerId;
}
```

컴포넌트 분리로 해결
A, B 클래스가 서로 순환 참조한다면 참조하는 부분을 따로 클래스로 만들어 분리한다.

### 더 알아볼 만한 주제
1. 항상 하면 좋은 고민
- final 이어야 할까?
- 이름은 뭘로하는게 좋을까?
2. VO의 변경자
비밀번호 변경 메서드를 새로운 VO를 반환하는 메서드가 되어야 한다.
- 새로운 VO를 반환한다.
- VO의 변경자 이름(e.g changePassword < withNewPassword)   

VO의 변경 메서드를 일반 변경 메서드와 구분하기 위해 메서드의 이름을 전치사로 시작하는 경우도 있다.

[돌아가기](#목차)

## SOLID

### Single response

단일 책임 원칙
> 단일 책임 원칙   
모든 클래스는 하나의 책임만 가지며, 클래스는 그 책임을 완전히 캡슐화해야 함을 일컫는다.
클래스가 제공하는 모든 기능은 이 책임과 주의 깊게 부합해야 한다.   
어떤 클래스나 모듈은 변경하려는 단 하나 이유만을 가져야 한다

**코드 라인이 100줄 이상이라면 의심해봐야 한다.**

[돌아가기](#목차)

### Open-Closed

개방-폐쇄 원칙
> 개방-폐쇄 원칙(OCP)은 소프트웨어 개체는(클래스, 모듈, 함수 등등)는 확장에 대해 열려있어야   하고, 수정에 대해서는 닫혀 있어야 한다.는 프로그래밍 원칙이다.   
개방-폐쇄 원칙이 잘 적용되면,    
기능을 추가하거나 변경해야 할 때 이미 제대로 동작하고 있던 원래 코드를 변경하지 않아도, 기존의 코드에 새로운 코드를 추가함으로써 기능의 추가나 변경이 가능하다.

**추상화가 부족한 경우에 개방-폐쇄 원칙이 제대로 안 지켜지고 있을 확률이 높다**

[돌아가기](#목차)

### 리스코프 치환 원칙
> 컴퓨터 프로그램에서 자료형 S가 자료형 T의 하위형이라면 필요한 프로그램의 속성(정확성, 수행하는 업무 등)의 변경 없이 자료형 T의 객체를 자료형 S의 객체로 교체(치환) 할 수 있어야 한다는 원칙

``` java

// 사각형
@Getter
@Setter
@AllArgsConstructor
class Rectangle {
    protected long width;
    protected long height;
}

// 정사각형
class Square extends Rectangle {
    public Square(long length) {
        super(length, length);
    }
}

Rectangle square = new Square(10)
square.setHeight(5);

=> 리스코프 치환 원칙 위배
```
**하위 자료형은 상위 자료형의 모든 동작을 완전히 대체 가능해야 한다.**

> public 메서드는 보통 인터페이스라고도 불린다.   
또한 인터페이스의 또 다른 이름 중 하나가 계약이다.   
=> setHeight 메서드는 높이를 변경한다는 '계약'이 있는 것이다   
이 계약이 상속을하면서 파기가 되었다. => 리스코프 치환 원칙 위배

[돌아가기](#목차)

### Interface-Segregation

인터페이스란?
> 인터페이스 또는 접속기는 서로 다른 두 개 이상의 독립된 컴퓨터 시스템 구성 요소 간에 정보를 교환하는 공유 경계이다.

public 메서드로 보면 편하다.
=> 이 기능을 사용하고 싶다면 이 방법을 사용하세요. 라고 알려주는 것

``` java
class User {
    private String email;
    private String password;
    private boolean active;

    public void inactivate() {
        this.active = false;
    }

    public boolean equalsPassword(String plainPassword) {
        String secretPassword = encode(plainPassword);
        return password.equals(secretPassword);
    }

    private String encode(String password) {
        return Encryptor.encode(password);
    }
}

inactive와 equalsPassword 메서드는 인터페이스 이다.
반면 encode 메서드는 인터페이스가 아니다.

그래서 인터페이스에선 private 메서드를 선언할 수 없다.
```


인터페이스 분리 원칙
> 인터페이스 분리 원칙은   
 클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다는 원칙이다.

``` java
public class LifecycleBean implements BeanNameAware, BeanFactoryAware {...}

여기서 Bean 관련 인터페이스를 구현하고 있으니 둘을 합쳐 버린다면?
BeanNameAware와 BeanFactoryAware 를 합쳐 인터페이스를 만든다면

public aspect AnnotationBeanConfigurerAspect implements BeanFactoryAware {...}
AnnotationBeanConfigurerAspect 클래스는 BeanFactoryAware 인터페이스만 구현하고 싶은데 
BeanNameAware 클래스의 불필요한 메서드 까지 구현하게 될 일이 생기게 된다.
```

[돌아가기](#목차)

### Dependency inversion
의존성 역전 원칙
> 첫째   
 상위 모듈은 하위 모듈에 의존해선 안된다.   
상위 모듈과 하위 모듈 모두 추상화에 의존해야 한다.   

> 둘째   
추상화는 세부 사항에 의존해선 안된다. 세부사항이 추상화에 의존해야 한다.

**구현체에 바로 의존할 경우 문제가 발생**

의존성이란? : A는 B를 사용하기만 해도 A는 B에 의존한다 할 수 있다.

``` java
class Chef {
    public Hamburger makeHamburger() {
        Bread bread = new Bread();
        Meat meat = new Meat();
        Lettuce lettuce = new Lettuce();
        Source source = new Source();
        return Hamburger.builder()
            .bread(bread)
            .meat(meat)
            .lettuce(lettuce)
            .source(source)
            .build();
    }
}

즉 셰프는 빵, 고기, 양상추, 소스, 햄버거에 의존한다고 볼 수 있다.
```

#### 의존성 주입
**의존성 주입이란 무엇인가?**
필요한 값을 외부에서 의존성을 넣어주면 의존성 주입이다.   
1. 파라미터 주입   
2. setter와 멤버 변수를 이용한 필드 주입
3. 생성자 주입   

``` java
class Chef {
    public Hamburger makeHamburger(
        Bread bread,
        Meat meat,
        Lettuce lettuce,
        Source source
    ) {
        return Hamburger.builder()
            .bread(bread)
            .meat(meat)
            .lettuce(lettuce)
            .source(source)
            .build();
    }
}

햄버거 만들기 위한 필요한 의존성들을 직접 인스턴스화 하지 않고 외부에서 받아와 사용하면 의존성 주입이다.
```

> 의존성 주입(DI)과 오해   
의존성이 사라진게 아닌 약해진 것이다.

**의존성 역전은 화살표의 방향을 반대로 바꾸는 테크닉 이다.**

McDonald -> HamburgerChef   
McDonald -> Chef(interface) <- HamburgerChef   
HamburgerChef 클래스의 입장에서 보면 화살표를 당하다 화살표를 쏘는 것으로 바뀌었다.   
=> 의존성 역전   
    
UserController -> UserService -> UserJpaRepository    
=> 의존성 역전을 지키지 않음 -> 절차 지향적인 코드가 나오게 된다.
   
**의존성 역전의 오해**   
- 무조건 추상화하라는 의미가 아니다.
- 추상화 유무는 개발자가 매번 판단을 잘해줘야 한다.

번외
의존성 주입과 책임 
- 생성자 의존성 주입이 7개 이상 넘어간다면
- 파라미터 의존성 주입이 4개 이상 넘어간다면   
   
=> 클래스 분할이나 메서드 분할을 고려해야 한다는 신호이다.   
    
IoC != DI   
스프링이 Inversion of Control Container 라는 말을 많이한다.   
그래서 Dependency Inversion을 제공한다 라고 생각하는 사람도 있으나   
아니다.

[돌아가기](#목차)


### 의존성 조언
**의존성을 드러내라**

의존성 숨겨진 예시 - 사용자가 로그인하면 로그인 시간을 기록 하도록 한다.

``` java
class User {
    private long lastLoginTimestamp;

    public void login() {
        this.lastLoginTimestamp = Clock.systemUTC().millis();
    }
}

=> 내부 로직을 보면 login은 분명 Clock에 의존적이다.

user.login();
외부에서 보면 login 이 시간에 의존하고 있음을 알 수가 없다.
```

``` java
class UserTest {
    @Test
    public void login_테스트() {
        // given
        User user = new User();

        // when
        user.login();

        // then
        assertThat(user.getLastLoginTimestamp()).isEqualTo(???);
    }
}
로그인 메서드를 호출한 시간이랑 결과를 비교하는 시간은 당연히 다르다.
로그인 했을 당시의 호출 시간을 알 방법도 없다.

=> 의존성을 드러내지 않아 테스트하기가 난해하다!
```

#### 개발자들이 의존성을 실수로 숨기게 되는 흔한 케이스
- 시간
- 랜덤(Random)
실행할 때마다 변하는 값들에서 실수가 발생할 수 있다.

#### 변하는 값은 주입 받아라

``` java
class User {
    private long lastLoginTimestamp;

    public void login(Clock clock) {
        this.lastLoginTimestamp = clock.millis();
    }
}

user.login(Clock.systemTUC());
=> 외부에서 보면 login은 분명히 시간이 필요한 메서드 이다.
```

``` java
class UserTest {
    @Test
    public void login_테스트() {
        // given
        User user = new User();
        Clock clock = Clock.fixed(Instant.parse("2000-01-01T00:00:00.00Z"), ZoneId.of("UTC"));

        // when
        user.login(clock);

        // then
        assertThat(user.getLastLoginTimestamp()).isEqualTo(946684800000L);
    }
}

=> 테스트하기가 쉬워진다!
login 전에 내가 사용할 시간 값을 미리 세팅할 수 있으므로
결과를 비교할 땐 내가 지정한 값과 일치하는지 확인만 하면 된다!
```

**UserService.login 은 여전히 시간에대한 의존성이 감춰져 있다!**
``` java
class UserService {
    public void login(User user) {
        user.login(Clock.systemUTC());
    }
}
UserService의 login 메서드를 보면 Clock 을 사용하는지 알 수 없다.
```

``` java
class UserServiceTest {
    @Test
    public void login_테스트() {
        // given
        User user = new User();
        UserService userService = new UserService();

        // when
        userService.login(user);

        // then
        asserThat(user.getLastLoginTimestamp()).isEqualTo(???)
    }
}

UserService는 테스트하기 어려워 진다.

똑같이 UserService에서 의존성을 드러내더라도 또 Controller에서 의존성을 드러내기 어려워진다
```

해답: 변하는 값을 추상화시켜라!
**결론적으로 변하는 값에 대한 가장 괜찮은 접근법은 런타임 의존성과 컴파일 타임 의존성을 다르게 하는 것이다.**


#### 변하는 값을 추상화 시켜라
``` java
interface ClockHolder {
    long getMillis();
}
```

``` java
@Getter
class User {
    private long lastLoginTimestamp;

    public void login(ClockHolder clockHolder) {
        this.lastLoginTimestamp = clockHolder.getMillis();
    }
}

@RequiredArgsConstructor
class UserService {
    private final ClockHolder clockHolder;

    public void login(User user) {
        user.login(clockHolder);
    }
}
컴파일 할 때는 ClockHolder에만 의존하면 된다.
현재 시간을 가져오는 기능은 CLockHolder를 구현한 객체가 알아서 책임지고 가져온다.
원래는 내가 현재 시간을 알아내야 했는데
다른 객체로 책임을 위임하였다!!
```

프로덕션 코드
``` java
class SystemClockHolder implements ClockHolder {
    @Override
    public long getMillis() {
        return Clock.systemUTC().millis();
    }
}
```

테스트 환경에서의 코드
``` java
@AllArgsConstructor
class TestClockHolder implements ClockHolder {

    private Clock clock;

    @Override
    public long getMillis() {
        return clock.millis();
    }
}

class UserServiceTest {
    @Test
    public void login_테스트() {
        // given
        Clock clock = Clock.fixed(Instant.parse("2000-01-01T00:00:00.00Z"), ZoneId.of("UTC"));
        User user = new User();
        UserService = userService = new UserService(new TestClockHolder(clock));

        // when
        userService.login(user);

        // then
        assertThat(user.getLastLoginTimestamp()).isEqualTo(946684800000L);
    }
}

UserService를 만들 때 고정된 시간을 갖고 있는 TestClockHolder를 건네주는 것
=> 테스트가 훨씬 쉬워지고, 테스트 코드도 쉽게 깨지지 않는다.
```
의존성 역전 원리를 이용하여 컴파일 타임과 런타임의 의존성을 다르게 했다.


[돌아가기](#목차)